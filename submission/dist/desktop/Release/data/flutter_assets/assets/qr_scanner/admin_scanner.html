<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>FitCity Admin QR Scanner</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: #101418;
        color: #e6edf3;
        font-family: "Segoe UI", Arial, sans-serif;
      }
      #root {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
      }
      #toolbar {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 14px;
        background: #151b22;
        border-bottom: 1px solid #223040;
      }
      body.compact #toolbar {
        display: none;
      }
      #stopBtn {
        background: #9b1c1c;
        color: #fff;
        border: none;
        border-radius: 6px;
        padding: 6px 12px;
        cursor: pointer;
      }
      #cameraSelect {
        flex: 1;
        background: #1c2430;
        color: #e6edf3;
        border: 1px solid #2c3a4f;
        border-radius: 6px;
        padding: 6px 8px;
      }
      #status {
        font-size: 12px;
        color: #9fb0c3;
      }
      #viewer {
        position: relative;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #0f141b;
        overflow: hidden;
      }
      #video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #0f141b;
      }
      #frame {
        position: absolute;
        width: 60%;
        max-width: 320px;
        aspect-ratio: 1 / 1;
        border: 2px solid #45b6fe;
        border-radius: 14px;
        box-shadow: 0 0 0 9999px rgba(10, 12, 18, 0.45);
      }
      body.compact #frame {
        width: 70%;
        max-width: 220px;
      }
      #note {
        position: absolute;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.45);
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
      }
      body.compact #note {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="root">
      <div id="toolbar">
        <button id="stopBtn">Stop camera</button>
        <select id="cameraSelect"></select>
        <span id="status">Initializing...</span>
      </div>
      <div id="viewer">
        <video id="video" autoplay playsinline></video>
        <div id="frame"></div>
        <div id="note">Align QR inside the frame</div>
      </div>
      <canvas id="canvas" style="display:none;"></canvas>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script>
      const statusEl = document.getElementById("status");
      const cameraSelect = document.getElementById("cameraSelect");
      const video = document.getElementById("video");
      const stopBtn = document.getElementById("stopBtn");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d", { willReadFrequently: true });

      let stream = null;
        let scanning = false;
        let detector = null;
        let lastResultAt = 0;
        let lastScanAt = 0;
        let scanLoopTicks = 0;
        const scanIntervalMs = 200;
        const debugIntervalMs = 1000;

      const params = new URLSearchParams(window.location.search);
      const isCompact = params.get("compact") === "1";
      if (isCompact) {
        document.body.classList.add("compact");
      }

      function sendMessage(payload) {
        try {
          const json = JSON.stringify(payload);
          if (window.chrome && window.chrome.webview) {
            window.chrome.webview.postMessage(json);
          } else {
            window.parent?.postMessage(json, "*");
          }
        } catch (err) {
          console.log("postMessage failed", err);
        }
      }

        function setStatus(text) {
          statusEl.textContent = text;
          sendMessage({ type: "status", message: text });
        }

      async function listCameras(tag) {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cameras = devices.filter((d) => d.kind === "videoinput");
        cameraSelect.innerHTML = "";
        cameras.forEach((camera, idx) => {
          const option = document.createElement("option");
          option.value = camera.deviceId;
          option.textContent = camera.label || `Camera ${idx + 1}`;
          cameraSelect.appendChild(option);
        });
        sendMessage({
          type: "devices",
          tag: tag || "list",
          devices: cameras.map((c) => ({ id: c.deviceId, label: c.label })),
        });
        return cameras;
      }

      async function stopStream() {
        if (stream) {
          stream.getTracks().forEach((track) => track.stop());
          stream = null;
        }
        video.srcObject = null;
      }

      async function startStream(deviceId) {
        await stopStream();
        let constraints = {
          audio: false,
          video: deviceId ? { deviceId: { exact: deviceId } } : true,
        };
        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          if (deviceId) {
            constraints = { audio: false, video: { deviceId: { ideal: deviceId } } };
            stream = await navigator.mediaDevices.getUserMedia(constraints);
          } else {
            throw err;
          }
        }
        video.srcObject = stream;
        await video.play();
      }

        function reportAspectRatio() {
          if (!video.videoWidth || !video.videoHeight) return;
          const ratio = video.videoWidth / video.videoHeight;
          sendMessage({ type: "aspect", value: ratio });
        }

        function reportDebug() {
          const ready = video.readyState;
          sendMessage({
            type: "debug",
            ticks: scanLoopTicks,
            readyState: ready,
            width: video.videoWidth || 0,
            height: video.videoHeight || 0,
            scanning: scanning,
          });
        }

        async function initCamera() {
          try {
            setStatus("Requesting camera permission...");
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error("getUserMedia not available in this runtime.");
          }
          await listCameras("before-permission");
          const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          tempStream.getTracks().forEach((track) => track.stop());
          const cameras = await listCameras("after-permission");
          const first = cameras[0];
          await startStream(first ? first.deviceId : null);
          reportAspectRatio();
          setStatus("Camera ready");
            await startScan();
          } catch (err) {
            const name = err?.name || "UnknownError";
            const msg = err?.message || "Camera permission denied or unavailable.";
            setStatus(`${name}: ${msg}`);
            sendMessage({
              type: "error",
              message: `${name}: ${msg}`,
            });
          }
        }

      async function startScan() {
        if (scanning) return;
        if (!("BarcodeDetector" in window) && !window.jsQR) {
          setStatus("No QR decoder available (BarcodeDetector/jsQR missing).");
          sendMessage({ type: "error", message: "No QR decoder available." });
          return;
        }
        if ("BarcodeDetector" in window) {
          detector = detector || new BarcodeDetector({ formats: ["qr_code"] });
        }
        scanning = true;
        requestAnimationFrame(scanLoop);
      }

      function stopScan() {
        scanning = false;
      }

        async function scanLoop() {
          if (!scanning) return;
          const now = Date.now();
          scanLoopTicks += 1;
          if (now - lastScanAt < scanIntervalMs) {
            requestAnimationFrame(scanLoop);
            return;
          }
          lastScanAt = now;
          if (video.readyState >= 2) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            try {
              if (detector) {
                const results = await detector.detect(canvas);
                if (results && results.length > 0) {
                  if (now - lastResultAt > 1200) {
                    lastResultAt = now;
                    scanning = false;
                    const value = results[0].rawValue || "";
                    sendMessage({ type: "scan", value, length: value.length, ts: now });
                  }
                }
              } else if (window.jsQR) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = window.jsQR(imageData.data, imageData.width, imageData.height);
                if (code && code.data) {
                  if (now - lastResultAt > 1200) {
                    lastResultAt = now;
                    scanning = false;
                    sendMessage({ type: "scan", value: code.data, length: code.data.length, ts: now });
                  }
                }
              }
            } catch (_) {}
          }
          requestAnimationFrame(scanLoop);
        }

      cameraSelect.addEventListener("change", async (e) => {
        const id = e.target.value;
        setStatus("Switching camera...");
        await startStream(id);
        reportAspectRatio();
        setStatus("Camera ready");
        startScan();
      });

      video.addEventListener("loadedmetadata", () => {
        reportAspectRatio();
      });

        window.initCamera = initCamera;
        window.startScan = startScan;
        window.stopScan = stopScan;
        window.stopStream = stopStream;
        window.stopAll = () => {
          stopScan();
          stopStream();
        };

        setStatus("Initializing...");
        document.addEventListener("DOMContentLoaded", () => {
          sendMessage({ type: "ready" });
          setInterval(reportDebug, debugIntervalMs);
        });

      stopBtn.addEventListener("click", async () => {
        stopScan();
        await stopStream();
        setStatus("Camera stopped.");
      });
    </script>
  </body>
</html>
